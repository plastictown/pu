#include <vector>
#include <memory>
#include <map>
#include <set>
#include <functional>
#include <cmath>
#include <iostream>
#include <string>
#include <utility>
#include <iterator> 
#include <list>
#include <cmath>
#include <stack>
#include <queue>

template<typename T>
  void PrintAnyCont( const T& c){
    for (const auto el: c){ // by value
      if constexpr ( std::is_pointer<decltype(el)>::value ){
        std::cout << *el << std::endl;
      }else{
        std::cout << el << std::endl;
      }// !else
    }// !for
  }// !PrintAnyCont
  
template <typename T>
  void PrintStack(const std::stack<T>& cont){
    struct inner_t: public std::stack<T>{
      using std::stack<T>::c;
    };
    const auto& inner = static_cast<const inner_t&>(cont).c;
    
    for(const auto& el: inner){
      std::cout << el << std::endl;
    }
  }

int main()
{
	/******************************************************************************/
	/*
	Задание 1. Реализуйте шаблон функции для вывода на печать элементов
	последовательностей которые могут содержать:
	•	как объекты любого типа,
	•	так и указатели на объекты любого типа (указатели распечатывать неинтересно
		=> в этом случае следует получать значение по адресу)
	Подсказки: if constexpr
	*/
	{	//Например:

		std::vector<std::string> vs = { "A", "B", "C" };
		PrintAnyCont(vs);

		std::string* ar[] = { new std::string("D"), new std::string("E"), new std::string("F") };
		PrintAnyCont(ar);	
     
		for(size_t i=0u; i < sizeof(ar)/sizeof(std::string*); ++i){
      delete ar[i];
    }
	}

	/******************************************************************************/
	/*
	Задание 2. Реализуйте шаблон функции вывода на печать значений элементов любого
	адаптера (stack, queue, priority_queue)
	Подсказки: if constexpr, is_same
	*/
	{
      std::stack<int> s;
      s.push(1);
      s.push(3);
      s.push(5);
		PrintStack(s);
	}

	/******************************************************************************/
	/*
	Задание 3. Реализуйте шаблон функции сложения двух значений.
	Если первое слагаемое является вектором, то все элементы вектора нужно увеличить
	на значение второго параметра. При этом элементы вектора и второй параметр должны быть
	одного и того же типа.
	Подсказки: if constexpr, is_same
	*/
	{

		;
	}

	/******************************************************************************/
	/*
	Задание 4. variadic template – функция. Свертка pack-а параметров
	Реализуйте функцию, которая умеет печатать любое количество параметров любого типа,
	испоьзуя a) variadic template, b) свертку.
	*/
	{	//Например: 		

		//MyPrint(4, 8.8, A(1), std::string("dfg"));  //a)

		//MyPrint2(4, 8.8, A(1), std::string("dfg"));  //b)

		;
	}

	/******************************************************************************/
	/*
	Задание 5. Удалите из vector (list, deque) все элементы, значения которых совпадают
	с элементами pack-а.
	*/
	{
		std::vector<int> v = { 1,2,3,1,4,1,5 };
		//EraseAll(v, 1, 4);

		std::list<int> l = { 1,2,3,1,4,1,5 };
		//EraseAll(l, 1, 4);		

		;
	}

	/******************************************************************************/
	/*
	Задание 6. Попытка вставки нескольких элементов в set – try_insertAll()
	Функция должна принимать любое количество элементов для вставки и пытаться их вставить в set.
	Если удалось вставить все требуемые значения, функция возвращает true, иначе false.
	*/
	{   //Например:

		std::set<int> my_set{ 1, 2, 3 };
		//bool b1 = try_insert_all(my_set, 4, 5, 6); // Вставляет все элементы.
													 // Возвращает true
		//bool b2 = try_insert_all(my_set, 7, 8, 2); // Вставляет 7, 8.
													 // Возвращает false, поскольку 2 уже присутствует
		;
	}

	/******************************************************************************/
	/*
	Задание 7. Проверка попадания всех параметров в заданный диапазон
	Напишите функцию InRange() таким образом, чтобы:
	*/
	{
		//InRange(10, 20, 1, 15, 30);		// --> false
		//InRange(10, 20, 11, 12, 13);		// --> true
		//InRange(5.0, 5.5, 5.1, 5.2, 5.3);	// --> true

		;
	}

	/******************************************************************************/

	//Задание 8. std::tuple
	//Создайте класс book (автор, заглавие, год издания...). 
	//Создайте библиотеку таким образом, чтобы книги хранились в упорядоченном виде.
	//Чтобы упорядочить совокупность книжек, нужно сформировать условие сравнения, то есть
	//перегрузить, например operator<. При реализации оператора хочется сформировать условие
	//с учетом всех данных!!! 

	//Подсказка: Для упорядочения удобно использовать шаблон std::tuple,
	//так как для std::tuple перегружены операторы ==,!=,<,<=,>,>=
	//,которые сравнивают два кортежа лексиграфически (в порядке следования членов).

	//Для проверки распечатайте библиотеку
	{

		;
	}

	/******************************************************************************/

	//Задание 9. shared_ptr и weak_ptr
	//Создаем генеалогическое дерево посредством класса human. В классе хранятся:
	//имя - string
	//возможно признак: жив или уже нет...
	//родители - shared_ptr (родители не всегда известны...)
	//дети - контейнер из weak_ptr (чтобы избежать циклических зависимостей)

	//Методы класса human:
	//конструктор - для инициализации имени и признака
	//конструктор копирования, оператор присваивания, move ???
	//статический метод child() - 
	//				должен создать создать и вернуть обертку для родившегося человека
	//				+ сформировать все связи ребенка с родителями и наоборот

	//Ввести возможность распечатать генеалогическое дерево для указанного индивидума
	{
		//История должна с кого-то начинаться => "Жили-были дед да баба, например, Адам и Ева"
		//(то есть на самом деле два деда и две бабы):


		//std::shared_ptr<human> grandM1(new human("Eva"));
		//...

		//у них появились дети - child():


		//а у детей в свою очередь свои дети:


		//...
		;
	}

	return 0;
}